---
- name: set Windows Server version var
  set_fact:
    windows_server_version: "{{ ansible_distribution | regex_findall('Windows Server (\\d{4})') | first }}"

- name: install feature Windows-Containers
  win_feature:
    name: 'Containers'
    state: present
  register: windows_container_status

- name: install feature NET-Framework-Features
  win_feature:
    name: 'NET-Framework-Features'
    state: present
  register: net_framework_status

- name: install feature Hyper-V
  win_feature:
    name: 'Hyper-V'
    include_management_tools: True
    state: present
  register: hyperv_status

# TODO: It can't be verified if reboot is actually need,
#       thus we have to do it each time operation is successful
- name: enable testsigning
  win_shell: |
    Bcdedit.exe -set TESTSIGNING ON
  register: bcdedit_status
  when: contrail_configuration.WINDOWS_ENABLE_TEST_SIGNING is defined

- name: reboot the system
  win_reboot:
    test_command: powershell.exe 'Get-WindowsFeature'
    pre_reboot_delay: 15
    post_reboot_delay: 15
  when: windows_container_status.reboot_required or
        hyperv_status.reboot_required or
        net_framework_status.reboot_required or
        (contrail_configuration.WINDOWS_ENABLE_TEST_SIGNING is defined and bcdedit_status.changed)

- name: wait for reconnection
  wait_for_connection:

# Chocolatey 0.10.13 released on March 15, 2019 has changed meaning of
# exit codes and is incompatible with win_chocolatey module (it's a new
# feature called "enhanced exit codes").
# Normally chocolatey is installed with first invocation of win_chocolatey
# module. To overcome the problem, we install chocolatey separately (step
# "install chocolatey" below) and disable the new feature (step "disable
# enhanced exit codes in chocolatey" below) before actually installing anything
# with chocolatey.
#
# TODO: Those two steps should be eventually removed once win_chocolatey
# module handles enhanced exit codes properly.
- name: install chocolatey
  win_shell: |
    Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))

- name: disable enhanced exit codes in chocolatey
  win_shell: |
    choco feature disable --name="useEnhancedExitCodes"

- name: install python 2.7.13
  win_chocolatey:
    name: python2
    version: 2.7.13
    state: present

- name: install NSSM
  win_chocolatey:
    name: nssm
    state: present

- name: install DockerProvider
  win_psmodule:
    name: DockerMsftProvider

- name: ensure docker config directory exists
  win_file:
    path: "{{ win_docker_config_dir }}"
    state: directory

- name: ensure docker config file exists
  win_file:
    path: "{{ win_docker_daemon_file }}"
    state: touch

- name: read docker config file
  register: docker_daemon_file
  win_shell: Get-Content "{{ win_docker_daemon_file }}"

- name: convert docker config entries to json
  set_fact:
    docker_daemon: "{{ docker_daemon_file.stdout | default('{}', true) | from_json }}"

- name: disable the nat network in docker config
  set_fact:
    docker_daemon: "{{ docker_daemon | combine({\"bridge\" : \"none\"}) }}"

- name: write config to daemon.json
  win_copy:
    content: "{{ docker_daemon | to_nice_json }}"
    dest: "{{ win_docker_daemon_file }}"

- name: install Docker-EE 18.03
  win_shell: "Install-Package Docker -ProviderName DockerMsftProvider -RequiredVersion 18.03 -Force"
  when: windows_server_version == '2016'

- name: install Docker-EE 18.09
  win_shell: "Install-Package Docker -ProviderName DockerMsftProvider -RequiredVersion 18.09 -Force"
  when: windows_server_version == '2019'

# DockerProvider by default starts Docker.
# However, in this role we don't care in what state Docker is right now.
# Actual start of Docker happens in `docker` role,
# which starts after this role,
# So we can just stop it here and start it again in `docker` role
- name: stop Docker
  win_service:
    name: docker
    state: stopped

- name: remove NetNat objects
  win_shell: |
    Get-NetNat | Remove-NetNat -Confirm:$false

# Workaround for flaky HNS behavior.
# Removing container networks sometimes ends with "Unspecified error".
# For environment cleanup in tests it is acceptable to just ignore this error
# (-ErrorAction SilentlyContinue). However, this is not acceptable for
# template creation (we don't want to have unreliable template).
- name: remove container networks on Windows Server 2016
  win_shell: |
    Get-ContainerNetwork | Remove-ContainerNetwork -ErrorAction SilentlyContinue -Force
    Get-ContainerNetwork | Remove-ContainerNetwork -Force
  when: windows_server_version == '2016'

- name: remove container networks on Windows Server 2019
  win_shell: |
    Get-HnsNetwork | Remove-HnsNetwork
  when: windows_server_version == '2019'

# Workaround (#1) for Docker/Windows behavior:
# When WinNAT is enabled and NetNat object associated with default bridge
# network created by Docker exists, ICMP/UDP packets bigger than MTU do
# not reach containers and the host itself.
# Workaround (#2) for win_service behavior:
# We use win_shell instead of win_service because for this particular service
# win_service seems to fail ("An error occurred while creating the pipeline"
# or "Service 'winnat' is not installed") while it works fine for other
# services like Docker.
# Workaround (#3) for Set-Service:
# We use Stop-Service instead of "Set-Service -Status Stopped" because of a
# known bug in powershell.
- name: stop winnat
  win_shell: Stop-Service winnat

- name: disable winnat
  win_shell: Set-Service -Name winnat -StartupType Disabled

- name: install MS Visual C++ Redists
  win_chocolatey:
    name: '{{ item }}'
    state: present
  with_items:
  - vcredist2013
  - vcredist2015

# This is needed by nodemgr.
- name: install MS Visual C++ Compiler for Python 2.7
  win_chocolatey:
    name: vcpython27
    state: present

- name: disable Windows Firewall
  win_firewall:
    profiles:
      - Public
      - Domain
      - Private
    state: disabled
